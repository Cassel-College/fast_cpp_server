// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: SystemHealthy.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_SystemHealthy_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_SystemHealthy_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_SystemHealthy_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_SystemHealthy_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_SystemHealthy_2eproto;
namespace SystemHealthy {
class CPUCoreInfo;
struct CPUCoreInfoDefaultTypeInternal;
extern CPUCoreInfoDefaultTypeInternal _CPUCoreInfo_default_instance_;
class CPUInfo;
struct CPUInfoDefaultTypeInternal;
extern CPUInfoDefaultTypeInternal _CPUInfo_default_instance_;
class DiskInfo;
struct DiskInfoDefaultTypeInternal;
extern DiskInfoDefaultTypeInternal _DiskInfo_default_instance_;
class GPUCoreInfo;
struct GPUCoreInfoDefaultTypeInternal;
extern GPUCoreInfoDefaultTypeInternal _GPUCoreInfo_default_instance_;
class GPUInfo;
struct GPUInfoDefaultTypeInternal;
extern GPUInfoDefaultTypeInternal _GPUInfo_default_instance_;
class MemInfo;
struct MemInfoDefaultTypeInternal;
extern MemInfoDefaultTypeInternal _MemInfo_default_instance_;
class NetInfo;
struct NetInfoDefaultTypeInternal;
extern NetInfoDefaultTypeInternal _NetInfo_default_instance_;
class ProcessInfo;
struct ProcessInfoDefaultTypeInternal;
extern ProcessInfoDefaultTypeInternal _ProcessInfo_default_instance_;
class SystemInfo;
struct SystemInfoDefaultTypeInternal;
extern SystemInfoDefaultTypeInternal _SystemInfo_default_instance_;
}  // namespace SystemHealthy
PROTOBUF_NAMESPACE_OPEN
template<> ::SystemHealthy::CPUCoreInfo* Arena::CreateMaybeMessage<::SystemHealthy::CPUCoreInfo>(Arena*);
template<> ::SystemHealthy::CPUInfo* Arena::CreateMaybeMessage<::SystemHealthy::CPUInfo>(Arena*);
template<> ::SystemHealthy::DiskInfo* Arena::CreateMaybeMessage<::SystemHealthy::DiskInfo>(Arena*);
template<> ::SystemHealthy::GPUCoreInfo* Arena::CreateMaybeMessage<::SystemHealthy::GPUCoreInfo>(Arena*);
template<> ::SystemHealthy::GPUInfo* Arena::CreateMaybeMessage<::SystemHealthy::GPUInfo>(Arena*);
template<> ::SystemHealthy::MemInfo* Arena::CreateMaybeMessage<::SystemHealthy::MemInfo>(Arena*);
template<> ::SystemHealthy::NetInfo* Arena::CreateMaybeMessage<::SystemHealthy::NetInfo>(Arena*);
template<> ::SystemHealthy::ProcessInfo* Arena::CreateMaybeMessage<::SystemHealthy::ProcessInfo>(Arena*);
template<> ::SystemHealthy::SystemInfo* Arena::CreateMaybeMessage<::SystemHealthy::SystemInfo>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace SystemHealthy {

// ===================================================================

class CPUCoreInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SystemHealthy.CPUCoreInfo) */ {
 public:
  inline CPUCoreInfo() : CPUCoreInfo(nullptr) {}
  ~CPUCoreInfo() override;
  explicit PROTOBUF_CONSTEXPR CPUCoreInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CPUCoreInfo(const CPUCoreInfo& from);
  CPUCoreInfo(CPUCoreInfo&& from) noexcept
    : CPUCoreInfo() {
    *this = ::std::move(from);
  }

  inline CPUCoreInfo& operator=(const CPUCoreInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline CPUCoreInfo& operator=(CPUCoreInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CPUCoreInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const CPUCoreInfo* internal_default_instance() {
    return reinterpret_cast<const CPUCoreInfo*>(
               &_CPUCoreInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(CPUCoreInfo& a, CPUCoreInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(CPUCoreInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CPUCoreInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CPUCoreInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CPUCoreInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CPUCoreInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CPUCoreInfo& from) {
    CPUCoreInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CPUCoreInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SystemHealthy.CPUCoreInfo";
  }
  protected:
  explicit CPUCoreInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCoreIdFieldNumber = 1,
    kUsagePercentFieldNumber = 2,
  };
  // int32 core_id = 1;
  void clear_core_id();
  int32_t core_id() const;
  void set_core_id(int32_t value);
  private:
  int32_t _internal_core_id() const;
  void _internal_set_core_id(int32_t value);
  public:

  // float usage_percent = 2;
  void clear_usage_percent();
  float usage_percent() const;
  void set_usage_percent(float value);
  private:
  float _internal_usage_percent() const;
  void _internal_set_usage_percent(float value);
  public:

  // @@protoc_insertion_point(class_scope:SystemHealthy.CPUCoreInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t core_id_;
    float usage_percent_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SystemHealthy_2eproto;
};
// -------------------------------------------------------------------

class CPUInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SystemHealthy.CPUInfo) */ {
 public:
  inline CPUInfo() : CPUInfo(nullptr) {}
  ~CPUInfo() override;
  explicit PROTOBUF_CONSTEXPR CPUInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CPUInfo(const CPUInfo& from);
  CPUInfo(CPUInfo&& from) noexcept
    : CPUInfo() {
    *this = ::std::move(from);
  }

  inline CPUInfo& operator=(const CPUInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline CPUInfo& operator=(CPUInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CPUInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const CPUInfo* internal_default_instance() {
    return reinterpret_cast<const CPUInfo*>(
               &_CPUInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(CPUInfo& a, CPUInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(CPUInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CPUInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CPUInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CPUInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CPUInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CPUInfo& from) {
    CPUInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CPUInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SystemHealthy.CPUInfo";
  }
  protected:
  explicit CPUInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCoresFieldNumber = 3,
    kArchitectureFieldNumber = 1,
    kCoreCountFieldNumber = 2,
  };
  // repeated .SystemHealthy.CPUCoreInfo cores = 3;
  int cores_size() const;
  private:
  int _internal_cores_size() const;
  public:
  void clear_cores();
  ::SystemHealthy::CPUCoreInfo* mutable_cores(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SystemHealthy::CPUCoreInfo >*
      mutable_cores();
  private:
  const ::SystemHealthy::CPUCoreInfo& _internal_cores(int index) const;
  ::SystemHealthy::CPUCoreInfo* _internal_add_cores();
  public:
  const ::SystemHealthy::CPUCoreInfo& cores(int index) const;
  ::SystemHealthy::CPUCoreInfo* add_cores();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SystemHealthy::CPUCoreInfo >&
      cores() const;

  // string architecture = 1;
  void clear_architecture();
  const std::string& architecture() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_architecture(ArgT0&& arg0, ArgT... args);
  std::string* mutable_architecture();
  PROTOBUF_NODISCARD std::string* release_architecture();
  void set_allocated_architecture(std::string* architecture);
  private:
  const std::string& _internal_architecture() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_architecture(const std::string& value);
  std::string* _internal_mutable_architecture();
  public:

  // int32 core_count = 2;
  void clear_core_count();
  int32_t core_count() const;
  void set_core_count(int32_t value);
  private:
  int32_t _internal_core_count() const;
  void _internal_set_core_count(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:SystemHealthy.CPUInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SystemHealthy::CPUCoreInfo > cores_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr architecture_;
    int32_t core_count_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SystemHealthy_2eproto;
};
// -------------------------------------------------------------------

class MemInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SystemHealthy.MemInfo) */ {
 public:
  inline MemInfo() : MemInfo(nullptr) {}
  ~MemInfo() override;
  explicit PROTOBUF_CONSTEXPR MemInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MemInfo(const MemInfo& from);
  MemInfo(MemInfo&& from) noexcept
    : MemInfo() {
    *this = ::std::move(from);
  }

  inline MemInfo& operator=(const MemInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline MemInfo& operator=(MemInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MemInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const MemInfo* internal_default_instance() {
    return reinterpret_cast<const MemInfo*>(
               &_MemInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(MemInfo& a, MemInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(MemInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MemInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MemInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MemInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MemInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MemInfo& from) {
    MemInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MemInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SystemHealthy.MemInfo";
  }
  protected:
  explicit MemInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTotalBytesFieldNumber = 1,
    kAvailableBytesFieldNumber = 2,
    kUsagePercentFieldNumber = 3,
  };
  // uint64 total_bytes = 1;
  void clear_total_bytes();
  uint64_t total_bytes() const;
  void set_total_bytes(uint64_t value);
  private:
  uint64_t _internal_total_bytes() const;
  void _internal_set_total_bytes(uint64_t value);
  public:

  // uint64 available_bytes = 2;
  void clear_available_bytes();
  uint64_t available_bytes() const;
  void set_available_bytes(uint64_t value);
  private:
  uint64_t _internal_available_bytes() const;
  void _internal_set_available_bytes(uint64_t value);
  public:

  // float usage_percent = 3;
  void clear_usage_percent();
  float usage_percent() const;
  void set_usage_percent(float value);
  private:
  float _internal_usage_percent() const;
  void _internal_set_usage_percent(float value);
  public:

  // @@protoc_insertion_point(class_scope:SystemHealthy.MemInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t total_bytes_;
    uint64_t available_bytes_;
    float usage_percent_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SystemHealthy_2eproto;
};
// -------------------------------------------------------------------

class DiskInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SystemHealthy.DiskInfo) */ {
 public:
  inline DiskInfo() : DiskInfo(nullptr) {}
  ~DiskInfo() override;
  explicit PROTOBUF_CONSTEXPR DiskInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DiskInfo(const DiskInfo& from);
  DiskInfo(DiskInfo&& from) noexcept
    : DiskInfo() {
    *this = ::std::move(from);
  }

  inline DiskInfo& operator=(const DiskInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline DiskInfo& operator=(DiskInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DiskInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const DiskInfo* internal_default_instance() {
    return reinterpret_cast<const DiskInfo*>(
               &_DiskInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(DiskInfo& a, DiskInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(DiskInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DiskInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DiskInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DiskInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DiskInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DiskInfo& from) {
    DiskInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DiskInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SystemHealthy.DiskInfo";
  }
  protected:
  explicit DiskInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReadBytesFieldNumber = 1,
    kWriteBytesFieldNumber = 2,
  };
  // uint64 read_bytes = 1;
  void clear_read_bytes();
  uint64_t read_bytes() const;
  void set_read_bytes(uint64_t value);
  private:
  uint64_t _internal_read_bytes() const;
  void _internal_set_read_bytes(uint64_t value);
  public:

  // uint64 write_bytes = 2;
  void clear_write_bytes();
  uint64_t write_bytes() const;
  void set_write_bytes(uint64_t value);
  private:
  uint64_t _internal_write_bytes() const;
  void _internal_set_write_bytes(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:SystemHealthy.DiskInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t read_bytes_;
    uint64_t write_bytes_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SystemHealthy_2eproto;
};
// -------------------------------------------------------------------

class NetInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SystemHealthy.NetInfo) */ {
 public:
  inline NetInfo() : NetInfo(nullptr) {}
  ~NetInfo() override;
  explicit PROTOBUF_CONSTEXPR NetInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NetInfo(const NetInfo& from);
  NetInfo(NetInfo&& from) noexcept
    : NetInfo() {
    *this = ::std::move(from);
  }

  inline NetInfo& operator=(const NetInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline NetInfo& operator=(NetInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NetInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const NetInfo* internal_default_instance() {
    return reinterpret_cast<const NetInfo*>(
               &_NetInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(NetInfo& a, NetInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(NetInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NetInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NetInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NetInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NetInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NetInfo& from) {
    NetInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NetInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SystemHealthy.NetInfo";
  }
  protected:
  explicit NetInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRecvBytesFieldNumber = 1,
    kTransmitBytesFieldNumber = 2,
  };
  // uint64 recv_bytes = 1;
  void clear_recv_bytes();
  uint64_t recv_bytes() const;
  void set_recv_bytes(uint64_t value);
  private:
  uint64_t _internal_recv_bytes() const;
  void _internal_set_recv_bytes(uint64_t value);
  public:

  // uint64 transmit_bytes = 2;
  void clear_transmit_bytes();
  uint64_t transmit_bytes() const;
  void set_transmit_bytes(uint64_t value);
  private:
  uint64_t _internal_transmit_bytes() const;
  void _internal_set_transmit_bytes(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:SystemHealthy.NetInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t recv_bytes_;
    uint64_t transmit_bytes_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SystemHealthy_2eproto;
};
// -------------------------------------------------------------------

class GPUCoreInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SystemHealthy.GPUCoreInfo) */ {
 public:
  inline GPUCoreInfo() : GPUCoreInfo(nullptr) {}
  ~GPUCoreInfo() override;
  explicit PROTOBUF_CONSTEXPR GPUCoreInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GPUCoreInfo(const GPUCoreInfo& from);
  GPUCoreInfo(GPUCoreInfo&& from) noexcept
    : GPUCoreInfo() {
    *this = ::std::move(from);
  }

  inline GPUCoreInfo& operator=(const GPUCoreInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline GPUCoreInfo& operator=(GPUCoreInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GPUCoreInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const GPUCoreInfo* internal_default_instance() {
    return reinterpret_cast<const GPUCoreInfo*>(
               &_GPUCoreInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(GPUCoreInfo& a, GPUCoreInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(GPUCoreInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GPUCoreInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GPUCoreInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GPUCoreInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GPUCoreInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GPUCoreInfo& from) {
    GPUCoreInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GPUCoreInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SystemHealthy.GPUCoreInfo";
  }
  protected:
  explicit GPUCoreInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCoreIdFieldNumber = 1,
    kUsagePercentFieldNumber = 2,
  };
  // int32 core_id = 1;
  void clear_core_id();
  int32_t core_id() const;
  void set_core_id(int32_t value);
  private:
  int32_t _internal_core_id() const;
  void _internal_set_core_id(int32_t value);
  public:

  // float usage_percent = 2;
  void clear_usage_percent();
  float usage_percent() const;
  void set_usage_percent(float value);
  private:
  float _internal_usage_percent() const;
  void _internal_set_usage_percent(float value);
  public:

  // @@protoc_insertion_point(class_scope:SystemHealthy.GPUCoreInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t core_id_;
    float usage_percent_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SystemHealthy_2eproto;
};
// -------------------------------------------------------------------

class GPUInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SystemHealthy.GPUInfo) */ {
 public:
  inline GPUInfo() : GPUInfo(nullptr) {}
  ~GPUInfo() override;
  explicit PROTOBUF_CONSTEXPR GPUInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GPUInfo(const GPUInfo& from);
  GPUInfo(GPUInfo&& from) noexcept
    : GPUInfo() {
    *this = ::std::move(from);
  }

  inline GPUInfo& operator=(const GPUInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline GPUInfo& operator=(GPUInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GPUInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const GPUInfo* internal_default_instance() {
    return reinterpret_cast<const GPUInfo*>(
               &_GPUInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(GPUInfo& a, GPUInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(GPUInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GPUInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GPUInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GPUInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GPUInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GPUInfo& from) {
    GPUInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GPUInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SystemHealthy.GPUInfo";
  }
  protected:
  explicit GPUInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCoresFieldNumber = 6,
    kVendorFieldNumber = 1,
    kModelFieldNumber = 2,
    kMemoryTotalBytesFieldNumber = 4,
    kMemoryUsedBytesFieldNumber = 5,
    kUsagePercentFieldNumber = 3,
  };
  // repeated .SystemHealthy.GPUCoreInfo cores = 6;
  int cores_size() const;
  private:
  int _internal_cores_size() const;
  public:
  void clear_cores();
  ::SystemHealthy::GPUCoreInfo* mutable_cores(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SystemHealthy::GPUCoreInfo >*
      mutable_cores();
  private:
  const ::SystemHealthy::GPUCoreInfo& _internal_cores(int index) const;
  ::SystemHealthy::GPUCoreInfo* _internal_add_cores();
  public:
  const ::SystemHealthy::GPUCoreInfo& cores(int index) const;
  ::SystemHealthy::GPUCoreInfo* add_cores();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SystemHealthy::GPUCoreInfo >&
      cores() const;

  // string vendor = 1;
  void clear_vendor();
  const std::string& vendor() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_vendor(ArgT0&& arg0, ArgT... args);
  std::string* mutable_vendor();
  PROTOBUF_NODISCARD std::string* release_vendor();
  void set_allocated_vendor(std::string* vendor);
  private:
  const std::string& _internal_vendor() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_vendor(const std::string& value);
  std::string* _internal_mutable_vendor();
  public:

  // string model = 2;
  void clear_model();
  const std::string& model() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_model(ArgT0&& arg0, ArgT... args);
  std::string* mutable_model();
  PROTOBUF_NODISCARD std::string* release_model();
  void set_allocated_model(std::string* model);
  private:
  const std::string& _internal_model() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_model(const std::string& value);
  std::string* _internal_mutable_model();
  public:

  // uint64 memory_total_bytes = 4;
  void clear_memory_total_bytes();
  uint64_t memory_total_bytes() const;
  void set_memory_total_bytes(uint64_t value);
  private:
  uint64_t _internal_memory_total_bytes() const;
  void _internal_set_memory_total_bytes(uint64_t value);
  public:

  // uint64 memory_used_bytes = 5;
  void clear_memory_used_bytes();
  uint64_t memory_used_bytes() const;
  void set_memory_used_bytes(uint64_t value);
  private:
  uint64_t _internal_memory_used_bytes() const;
  void _internal_set_memory_used_bytes(uint64_t value);
  public:

  // float usage_percent = 3;
  void clear_usage_percent();
  float usage_percent() const;
  void set_usage_percent(float value);
  private:
  float _internal_usage_percent() const;
  void _internal_set_usage_percent(float value);
  public:

  // @@protoc_insertion_point(class_scope:SystemHealthy.GPUInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SystemHealthy::GPUCoreInfo > cores_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vendor_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_;
    uint64_t memory_total_bytes_;
    uint64_t memory_used_bytes_;
    float usage_percent_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SystemHealthy_2eproto;
};
// -------------------------------------------------------------------

class ProcessInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SystemHealthy.ProcessInfo) */ {
 public:
  inline ProcessInfo() : ProcessInfo(nullptr) {}
  ~ProcessInfo() override;
  explicit PROTOBUF_CONSTEXPR ProcessInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProcessInfo(const ProcessInfo& from);
  ProcessInfo(ProcessInfo&& from) noexcept
    : ProcessInfo() {
    *this = ::std::move(from);
  }

  inline ProcessInfo& operator=(const ProcessInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProcessInfo& operator=(ProcessInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProcessInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProcessInfo* internal_default_instance() {
    return reinterpret_cast<const ProcessInfo*>(
               &_ProcessInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ProcessInfo& a, ProcessInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ProcessInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProcessInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProcessInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProcessInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ProcessInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ProcessInfo& from) {
    ProcessInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProcessInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SystemHealthy.ProcessInfo";
  }
  protected:
  explicit ProcessInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kPidFieldNumber = 1,
    kCpuPercentFieldNumber = 3,
    kMemPercentFieldNumber = 4,
  };
  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // int32 pid = 1;
  void clear_pid();
  int32_t pid() const;
  void set_pid(int32_t value);
  private:
  int32_t _internal_pid() const;
  void _internal_set_pid(int32_t value);
  public:

  // float cpu_percent = 3;
  void clear_cpu_percent();
  float cpu_percent() const;
  void set_cpu_percent(float value);
  private:
  float _internal_cpu_percent() const;
  void _internal_set_cpu_percent(float value);
  public:

  // float mem_percent = 4;
  void clear_mem_percent();
  float mem_percent() const;
  void set_mem_percent(float value);
  private:
  float _internal_mem_percent() const;
  void _internal_set_mem_percent(float value);
  public:

  // @@protoc_insertion_point(class_scope:SystemHealthy.ProcessInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    int32_t pid_;
    float cpu_percent_;
    float mem_percent_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SystemHealthy_2eproto;
};
// -------------------------------------------------------------------

class SystemInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SystemHealthy.SystemInfo) */ {
 public:
  inline SystemInfo() : SystemInfo(nullptr) {}
  ~SystemInfo() override;
  explicit PROTOBUF_CONSTEXPR SystemInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SystemInfo(const SystemInfo& from);
  SystemInfo(SystemInfo&& from) noexcept
    : SystemInfo() {
    *this = ::std::move(from);
  }

  inline SystemInfo& operator=(const SystemInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline SystemInfo& operator=(SystemInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SystemInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const SystemInfo* internal_default_instance() {
    return reinterpret_cast<const SystemInfo*>(
               &_SystemInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(SystemInfo& a, SystemInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(SystemInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SystemInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SystemInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SystemInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SystemInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SystemInfo& from) {
    SystemInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SystemInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SystemHealthy.SystemInfo";
  }
  protected:
  explicit SystemInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGpuInfosFieldNumber = 8,
    kProcessesFieldNumber = 9,
    kOsNameFieldNumber = 1,
    kPlatformFieldNumber = 2,
    kCpuInfoFieldNumber = 4,
    kMemInfoFieldNumber = 5,
    kDiskInfoFieldNumber = 6,
    kNetInfoFieldNumber = 7,
    kUptimeSecondsFieldNumber = 3,
  };
  // repeated .SystemHealthy.GPUInfo gpu_infos = 8;
  int gpu_infos_size() const;
  private:
  int _internal_gpu_infos_size() const;
  public:
  void clear_gpu_infos();
  ::SystemHealthy::GPUInfo* mutable_gpu_infos(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SystemHealthy::GPUInfo >*
      mutable_gpu_infos();
  private:
  const ::SystemHealthy::GPUInfo& _internal_gpu_infos(int index) const;
  ::SystemHealthy::GPUInfo* _internal_add_gpu_infos();
  public:
  const ::SystemHealthy::GPUInfo& gpu_infos(int index) const;
  ::SystemHealthy::GPUInfo* add_gpu_infos();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SystemHealthy::GPUInfo >&
      gpu_infos() const;

  // repeated .SystemHealthy.ProcessInfo processes = 9;
  int processes_size() const;
  private:
  int _internal_processes_size() const;
  public:
  void clear_processes();
  ::SystemHealthy::ProcessInfo* mutable_processes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SystemHealthy::ProcessInfo >*
      mutable_processes();
  private:
  const ::SystemHealthy::ProcessInfo& _internal_processes(int index) const;
  ::SystemHealthy::ProcessInfo* _internal_add_processes();
  public:
  const ::SystemHealthy::ProcessInfo& processes(int index) const;
  ::SystemHealthy::ProcessInfo* add_processes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SystemHealthy::ProcessInfo >&
      processes() const;

  // string os_name = 1;
  void clear_os_name();
  const std::string& os_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_os_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_os_name();
  PROTOBUF_NODISCARD std::string* release_os_name();
  void set_allocated_os_name(std::string* os_name);
  private:
  const std::string& _internal_os_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_os_name(const std::string& value);
  std::string* _internal_mutable_os_name();
  public:

  // string platform = 2;
  void clear_platform();
  const std::string& platform() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_platform(ArgT0&& arg0, ArgT... args);
  std::string* mutable_platform();
  PROTOBUF_NODISCARD std::string* release_platform();
  void set_allocated_platform(std::string* platform);
  private:
  const std::string& _internal_platform() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_platform(const std::string& value);
  std::string* _internal_mutable_platform();
  public:

  // .SystemHealthy.CPUInfo cpu_info = 4;
  bool has_cpu_info() const;
  private:
  bool _internal_has_cpu_info() const;
  public:
  void clear_cpu_info();
  const ::SystemHealthy::CPUInfo& cpu_info() const;
  PROTOBUF_NODISCARD ::SystemHealthy::CPUInfo* release_cpu_info();
  ::SystemHealthy::CPUInfo* mutable_cpu_info();
  void set_allocated_cpu_info(::SystemHealthy::CPUInfo* cpu_info);
  private:
  const ::SystemHealthy::CPUInfo& _internal_cpu_info() const;
  ::SystemHealthy::CPUInfo* _internal_mutable_cpu_info();
  public:
  void unsafe_arena_set_allocated_cpu_info(
      ::SystemHealthy::CPUInfo* cpu_info);
  ::SystemHealthy::CPUInfo* unsafe_arena_release_cpu_info();

  // .SystemHealthy.MemInfo mem_info = 5;
  bool has_mem_info() const;
  private:
  bool _internal_has_mem_info() const;
  public:
  void clear_mem_info();
  const ::SystemHealthy::MemInfo& mem_info() const;
  PROTOBUF_NODISCARD ::SystemHealthy::MemInfo* release_mem_info();
  ::SystemHealthy::MemInfo* mutable_mem_info();
  void set_allocated_mem_info(::SystemHealthy::MemInfo* mem_info);
  private:
  const ::SystemHealthy::MemInfo& _internal_mem_info() const;
  ::SystemHealthy::MemInfo* _internal_mutable_mem_info();
  public:
  void unsafe_arena_set_allocated_mem_info(
      ::SystemHealthy::MemInfo* mem_info);
  ::SystemHealthy::MemInfo* unsafe_arena_release_mem_info();

  // .SystemHealthy.DiskInfo disk_info = 6;
  bool has_disk_info() const;
  private:
  bool _internal_has_disk_info() const;
  public:
  void clear_disk_info();
  const ::SystemHealthy::DiskInfo& disk_info() const;
  PROTOBUF_NODISCARD ::SystemHealthy::DiskInfo* release_disk_info();
  ::SystemHealthy::DiskInfo* mutable_disk_info();
  void set_allocated_disk_info(::SystemHealthy::DiskInfo* disk_info);
  private:
  const ::SystemHealthy::DiskInfo& _internal_disk_info() const;
  ::SystemHealthy::DiskInfo* _internal_mutable_disk_info();
  public:
  void unsafe_arena_set_allocated_disk_info(
      ::SystemHealthy::DiskInfo* disk_info);
  ::SystemHealthy::DiskInfo* unsafe_arena_release_disk_info();

  // .SystemHealthy.NetInfo net_info = 7;
  bool has_net_info() const;
  private:
  bool _internal_has_net_info() const;
  public:
  void clear_net_info();
  const ::SystemHealthy::NetInfo& net_info() const;
  PROTOBUF_NODISCARD ::SystemHealthy::NetInfo* release_net_info();
  ::SystemHealthy::NetInfo* mutable_net_info();
  void set_allocated_net_info(::SystemHealthy::NetInfo* net_info);
  private:
  const ::SystemHealthy::NetInfo& _internal_net_info() const;
  ::SystemHealthy::NetInfo* _internal_mutable_net_info();
  public:
  void unsafe_arena_set_allocated_net_info(
      ::SystemHealthy::NetInfo* net_info);
  ::SystemHealthy::NetInfo* unsafe_arena_release_net_info();

  // uint64 uptime_seconds = 3;
  void clear_uptime_seconds();
  uint64_t uptime_seconds() const;
  void set_uptime_seconds(uint64_t value);
  private:
  uint64_t _internal_uptime_seconds() const;
  void _internal_set_uptime_seconds(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:SystemHealthy.SystemInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SystemHealthy::GPUInfo > gpu_infos_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SystemHealthy::ProcessInfo > processes_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr os_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr platform_;
    ::SystemHealthy::CPUInfo* cpu_info_;
    ::SystemHealthy::MemInfo* mem_info_;
    ::SystemHealthy::DiskInfo* disk_info_;
    ::SystemHealthy::NetInfo* net_info_;
    uint64_t uptime_seconds_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SystemHealthy_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// CPUCoreInfo

// int32 core_id = 1;
inline void CPUCoreInfo::clear_core_id() {
  _impl_.core_id_ = 0;
}
inline int32_t CPUCoreInfo::_internal_core_id() const {
  return _impl_.core_id_;
}
inline int32_t CPUCoreInfo::core_id() const {
  // @@protoc_insertion_point(field_get:SystemHealthy.CPUCoreInfo.core_id)
  return _internal_core_id();
}
inline void CPUCoreInfo::_internal_set_core_id(int32_t value) {
  
  _impl_.core_id_ = value;
}
inline void CPUCoreInfo::set_core_id(int32_t value) {
  _internal_set_core_id(value);
  // @@protoc_insertion_point(field_set:SystemHealthy.CPUCoreInfo.core_id)
}

// float usage_percent = 2;
inline void CPUCoreInfo::clear_usage_percent() {
  _impl_.usage_percent_ = 0;
}
inline float CPUCoreInfo::_internal_usage_percent() const {
  return _impl_.usage_percent_;
}
inline float CPUCoreInfo::usage_percent() const {
  // @@protoc_insertion_point(field_get:SystemHealthy.CPUCoreInfo.usage_percent)
  return _internal_usage_percent();
}
inline void CPUCoreInfo::_internal_set_usage_percent(float value) {
  
  _impl_.usage_percent_ = value;
}
inline void CPUCoreInfo::set_usage_percent(float value) {
  _internal_set_usage_percent(value);
  // @@protoc_insertion_point(field_set:SystemHealthy.CPUCoreInfo.usage_percent)
}

// -------------------------------------------------------------------

// CPUInfo

// string architecture = 1;
inline void CPUInfo::clear_architecture() {
  _impl_.architecture_.ClearToEmpty();
}
inline const std::string& CPUInfo::architecture() const {
  // @@protoc_insertion_point(field_get:SystemHealthy.CPUInfo.architecture)
  return _internal_architecture();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CPUInfo::set_architecture(ArgT0&& arg0, ArgT... args) {
 
 _impl_.architecture_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SystemHealthy.CPUInfo.architecture)
}
inline std::string* CPUInfo::mutable_architecture() {
  std::string* _s = _internal_mutable_architecture();
  // @@protoc_insertion_point(field_mutable:SystemHealthy.CPUInfo.architecture)
  return _s;
}
inline const std::string& CPUInfo::_internal_architecture() const {
  return _impl_.architecture_.Get();
}
inline void CPUInfo::_internal_set_architecture(const std::string& value) {
  
  _impl_.architecture_.Set(value, GetArenaForAllocation());
}
inline std::string* CPUInfo::_internal_mutable_architecture() {
  
  return _impl_.architecture_.Mutable(GetArenaForAllocation());
}
inline std::string* CPUInfo::release_architecture() {
  // @@protoc_insertion_point(field_release:SystemHealthy.CPUInfo.architecture)
  return _impl_.architecture_.Release();
}
inline void CPUInfo::set_allocated_architecture(std::string* architecture) {
  if (architecture != nullptr) {
    
  } else {
    
  }
  _impl_.architecture_.SetAllocated(architecture, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.architecture_.IsDefault()) {
    _impl_.architecture_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SystemHealthy.CPUInfo.architecture)
}

// int32 core_count = 2;
inline void CPUInfo::clear_core_count() {
  _impl_.core_count_ = 0;
}
inline int32_t CPUInfo::_internal_core_count() const {
  return _impl_.core_count_;
}
inline int32_t CPUInfo::core_count() const {
  // @@protoc_insertion_point(field_get:SystemHealthy.CPUInfo.core_count)
  return _internal_core_count();
}
inline void CPUInfo::_internal_set_core_count(int32_t value) {
  
  _impl_.core_count_ = value;
}
inline void CPUInfo::set_core_count(int32_t value) {
  _internal_set_core_count(value);
  // @@protoc_insertion_point(field_set:SystemHealthy.CPUInfo.core_count)
}

// repeated .SystemHealthy.CPUCoreInfo cores = 3;
inline int CPUInfo::_internal_cores_size() const {
  return _impl_.cores_.size();
}
inline int CPUInfo::cores_size() const {
  return _internal_cores_size();
}
inline void CPUInfo::clear_cores() {
  _impl_.cores_.Clear();
}
inline ::SystemHealthy::CPUCoreInfo* CPUInfo::mutable_cores(int index) {
  // @@protoc_insertion_point(field_mutable:SystemHealthy.CPUInfo.cores)
  return _impl_.cores_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SystemHealthy::CPUCoreInfo >*
CPUInfo::mutable_cores() {
  // @@protoc_insertion_point(field_mutable_list:SystemHealthy.CPUInfo.cores)
  return &_impl_.cores_;
}
inline const ::SystemHealthy::CPUCoreInfo& CPUInfo::_internal_cores(int index) const {
  return _impl_.cores_.Get(index);
}
inline const ::SystemHealthy::CPUCoreInfo& CPUInfo::cores(int index) const {
  // @@protoc_insertion_point(field_get:SystemHealthy.CPUInfo.cores)
  return _internal_cores(index);
}
inline ::SystemHealthy::CPUCoreInfo* CPUInfo::_internal_add_cores() {
  return _impl_.cores_.Add();
}
inline ::SystemHealthy::CPUCoreInfo* CPUInfo::add_cores() {
  ::SystemHealthy::CPUCoreInfo* _add = _internal_add_cores();
  // @@protoc_insertion_point(field_add:SystemHealthy.CPUInfo.cores)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SystemHealthy::CPUCoreInfo >&
CPUInfo::cores() const {
  // @@protoc_insertion_point(field_list:SystemHealthy.CPUInfo.cores)
  return _impl_.cores_;
}

// -------------------------------------------------------------------

// MemInfo

// uint64 total_bytes = 1;
inline void MemInfo::clear_total_bytes() {
  _impl_.total_bytes_ = uint64_t{0u};
}
inline uint64_t MemInfo::_internal_total_bytes() const {
  return _impl_.total_bytes_;
}
inline uint64_t MemInfo::total_bytes() const {
  // @@protoc_insertion_point(field_get:SystemHealthy.MemInfo.total_bytes)
  return _internal_total_bytes();
}
inline void MemInfo::_internal_set_total_bytes(uint64_t value) {
  
  _impl_.total_bytes_ = value;
}
inline void MemInfo::set_total_bytes(uint64_t value) {
  _internal_set_total_bytes(value);
  // @@protoc_insertion_point(field_set:SystemHealthy.MemInfo.total_bytes)
}

// uint64 available_bytes = 2;
inline void MemInfo::clear_available_bytes() {
  _impl_.available_bytes_ = uint64_t{0u};
}
inline uint64_t MemInfo::_internal_available_bytes() const {
  return _impl_.available_bytes_;
}
inline uint64_t MemInfo::available_bytes() const {
  // @@protoc_insertion_point(field_get:SystemHealthy.MemInfo.available_bytes)
  return _internal_available_bytes();
}
inline void MemInfo::_internal_set_available_bytes(uint64_t value) {
  
  _impl_.available_bytes_ = value;
}
inline void MemInfo::set_available_bytes(uint64_t value) {
  _internal_set_available_bytes(value);
  // @@protoc_insertion_point(field_set:SystemHealthy.MemInfo.available_bytes)
}

// float usage_percent = 3;
inline void MemInfo::clear_usage_percent() {
  _impl_.usage_percent_ = 0;
}
inline float MemInfo::_internal_usage_percent() const {
  return _impl_.usage_percent_;
}
inline float MemInfo::usage_percent() const {
  // @@protoc_insertion_point(field_get:SystemHealthy.MemInfo.usage_percent)
  return _internal_usage_percent();
}
inline void MemInfo::_internal_set_usage_percent(float value) {
  
  _impl_.usage_percent_ = value;
}
inline void MemInfo::set_usage_percent(float value) {
  _internal_set_usage_percent(value);
  // @@protoc_insertion_point(field_set:SystemHealthy.MemInfo.usage_percent)
}

// -------------------------------------------------------------------

// DiskInfo

// uint64 read_bytes = 1;
inline void DiskInfo::clear_read_bytes() {
  _impl_.read_bytes_ = uint64_t{0u};
}
inline uint64_t DiskInfo::_internal_read_bytes() const {
  return _impl_.read_bytes_;
}
inline uint64_t DiskInfo::read_bytes() const {
  // @@protoc_insertion_point(field_get:SystemHealthy.DiskInfo.read_bytes)
  return _internal_read_bytes();
}
inline void DiskInfo::_internal_set_read_bytes(uint64_t value) {
  
  _impl_.read_bytes_ = value;
}
inline void DiskInfo::set_read_bytes(uint64_t value) {
  _internal_set_read_bytes(value);
  // @@protoc_insertion_point(field_set:SystemHealthy.DiskInfo.read_bytes)
}

// uint64 write_bytes = 2;
inline void DiskInfo::clear_write_bytes() {
  _impl_.write_bytes_ = uint64_t{0u};
}
inline uint64_t DiskInfo::_internal_write_bytes() const {
  return _impl_.write_bytes_;
}
inline uint64_t DiskInfo::write_bytes() const {
  // @@protoc_insertion_point(field_get:SystemHealthy.DiskInfo.write_bytes)
  return _internal_write_bytes();
}
inline void DiskInfo::_internal_set_write_bytes(uint64_t value) {
  
  _impl_.write_bytes_ = value;
}
inline void DiskInfo::set_write_bytes(uint64_t value) {
  _internal_set_write_bytes(value);
  // @@protoc_insertion_point(field_set:SystemHealthy.DiskInfo.write_bytes)
}

// -------------------------------------------------------------------

// NetInfo

// uint64 recv_bytes = 1;
inline void NetInfo::clear_recv_bytes() {
  _impl_.recv_bytes_ = uint64_t{0u};
}
inline uint64_t NetInfo::_internal_recv_bytes() const {
  return _impl_.recv_bytes_;
}
inline uint64_t NetInfo::recv_bytes() const {
  // @@protoc_insertion_point(field_get:SystemHealthy.NetInfo.recv_bytes)
  return _internal_recv_bytes();
}
inline void NetInfo::_internal_set_recv_bytes(uint64_t value) {
  
  _impl_.recv_bytes_ = value;
}
inline void NetInfo::set_recv_bytes(uint64_t value) {
  _internal_set_recv_bytes(value);
  // @@protoc_insertion_point(field_set:SystemHealthy.NetInfo.recv_bytes)
}

// uint64 transmit_bytes = 2;
inline void NetInfo::clear_transmit_bytes() {
  _impl_.transmit_bytes_ = uint64_t{0u};
}
inline uint64_t NetInfo::_internal_transmit_bytes() const {
  return _impl_.transmit_bytes_;
}
inline uint64_t NetInfo::transmit_bytes() const {
  // @@protoc_insertion_point(field_get:SystemHealthy.NetInfo.transmit_bytes)
  return _internal_transmit_bytes();
}
inline void NetInfo::_internal_set_transmit_bytes(uint64_t value) {
  
  _impl_.transmit_bytes_ = value;
}
inline void NetInfo::set_transmit_bytes(uint64_t value) {
  _internal_set_transmit_bytes(value);
  // @@protoc_insertion_point(field_set:SystemHealthy.NetInfo.transmit_bytes)
}

// -------------------------------------------------------------------

// GPUCoreInfo

// int32 core_id = 1;
inline void GPUCoreInfo::clear_core_id() {
  _impl_.core_id_ = 0;
}
inline int32_t GPUCoreInfo::_internal_core_id() const {
  return _impl_.core_id_;
}
inline int32_t GPUCoreInfo::core_id() const {
  // @@protoc_insertion_point(field_get:SystemHealthy.GPUCoreInfo.core_id)
  return _internal_core_id();
}
inline void GPUCoreInfo::_internal_set_core_id(int32_t value) {
  
  _impl_.core_id_ = value;
}
inline void GPUCoreInfo::set_core_id(int32_t value) {
  _internal_set_core_id(value);
  // @@protoc_insertion_point(field_set:SystemHealthy.GPUCoreInfo.core_id)
}

// float usage_percent = 2;
inline void GPUCoreInfo::clear_usage_percent() {
  _impl_.usage_percent_ = 0;
}
inline float GPUCoreInfo::_internal_usage_percent() const {
  return _impl_.usage_percent_;
}
inline float GPUCoreInfo::usage_percent() const {
  // @@protoc_insertion_point(field_get:SystemHealthy.GPUCoreInfo.usage_percent)
  return _internal_usage_percent();
}
inline void GPUCoreInfo::_internal_set_usage_percent(float value) {
  
  _impl_.usage_percent_ = value;
}
inline void GPUCoreInfo::set_usage_percent(float value) {
  _internal_set_usage_percent(value);
  // @@protoc_insertion_point(field_set:SystemHealthy.GPUCoreInfo.usage_percent)
}

// -------------------------------------------------------------------

// GPUInfo

// string vendor = 1;
inline void GPUInfo::clear_vendor() {
  _impl_.vendor_.ClearToEmpty();
}
inline const std::string& GPUInfo::vendor() const {
  // @@protoc_insertion_point(field_get:SystemHealthy.GPUInfo.vendor)
  return _internal_vendor();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GPUInfo::set_vendor(ArgT0&& arg0, ArgT... args) {
 
 _impl_.vendor_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SystemHealthy.GPUInfo.vendor)
}
inline std::string* GPUInfo::mutable_vendor() {
  std::string* _s = _internal_mutable_vendor();
  // @@protoc_insertion_point(field_mutable:SystemHealthy.GPUInfo.vendor)
  return _s;
}
inline const std::string& GPUInfo::_internal_vendor() const {
  return _impl_.vendor_.Get();
}
inline void GPUInfo::_internal_set_vendor(const std::string& value) {
  
  _impl_.vendor_.Set(value, GetArenaForAllocation());
}
inline std::string* GPUInfo::_internal_mutable_vendor() {
  
  return _impl_.vendor_.Mutable(GetArenaForAllocation());
}
inline std::string* GPUInfo::release_vendor() {
  // @@protoc_insertion_point(field_release:SystemHealthy.GPUInfo.vendor)
  return _impl_.vendor_.Release();
}
inline void GPUInfo::set_allocated_vendor(std::string* vendor) {
  if (vendor != nullptr) {
    
  } else {
    
  }
  _impl_.vendor_.SetAllocated(vendor, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.vendor_.IsDefault()) {
    _impl_.vendor_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SystemHealthy.GPUInfo.vendor)
}

// string model = 2;
inline void GPUInfo::clear_model() {
  _impl_.model_.ClearToEmpty();
}
inline const std::string& GPUInfo::model() const {
  // @@protoc_insertion_point(field_get:SystemHealthy.GPUInfo.model)
  return _internal_model();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GPUInfo::set_model(ArgT0&& arg0, ArgT... args) {
 
 _impl_.model_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SystemHealthy.GPUInfo.model)
}
inline std::string* GPUInfo::mutable_model() {
  std::string* _s = _internal_mutable_model();
  // @@protoc_insertion_point(field_mutable:SystemHealthy.GPUInfo.model)
  return _s;
}
inline const std::string& GPUInfo::_internal_model() const {
  return _impl_.model_.Get();
}
inline void GPUInfo::_internal_set_model(const std::string& value) {
  
  _impl_.model_.Set(value, GetArenaForAllocation());
}
inline std::string* GPUInfo::_internal_mutable_model() {
  
  return _impl_.model_.Mutable(GetArenaForAllocation());
}
inline std::string* GPUInfo::release_model() {
  // @@protoc_insertion_point(field_release:SystemHealthy.GPUInfo.model)
  return _impl_.model_.Release();
}
inline void GPUInfo::set_allocated_model(std::string* model) {
  if (model != nullptr) {
    
  } else {
    
  }
  _impl_.model_.SetAllocated(model, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.model_.IsDefault()) {
    _impl_.model_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SystemHealthy.GPUInfo.model)
}

// float usage_percent = 3;
inline void GPUInfo::clear_usage_percent() {
  _impl_.usage_percent_ = 0;
}
inline float GPUInfo::_internal_usage_percent() const {
  return _impl_.usage_percent_;
}
inline float GPUInfo::usage_percent() const {
  // @@protoc_insertion_point(field_get:SystemHealthy.GPUInfo.usage_percent)
  return _internal_usage_percent();
}
inline void GPUInfo::_internal_set_usage_percent(float value) {
  
  _impl_.usage_percent_ = value;
}
inline void GPUInfo::set_usage_percent(float value) {
  _internal_set_usage_percent(value);
  // @@protoc_insertion_point(field_set:SystemHealthy.GPUInfo.usage_percent)
}

// uint64 memory_total_bytes = 4;
inline void GPUInfo::clear_memory_total_bytes() {
  _impl_.memory_total_bytes_ = uint64_t{0u};
}
inline uint64_t GPUInfo::_internal_memory_total_bytes() const {
  return _impl_.memory_total_bytes_;
}
inline uint64_t GPUInfo::memory_total_bytes() const {
  // @@protoc_insertion_point(field_get:SystemHealthy.GPUInfo.memory_total_bytes)
  return _internal_memory_total_bytes();
}
inline void GPUInfo::_internal_set_memory_total_bytes(uint64_t value) {
  
  _impl_.memory_total_bytes_ = value;
}
inline void GPUInfo::set_memory_total_bytes(uint64_t value) {
  _internal_set_memory_total_bytes(value);
  // @@protoc_insertion_point(field_set:SystemHealthy.GPUInfo.memory_total_bytes)
}

// uint64 memory_used_bytes = 5;
inline void GPUInfo::clear_memory_used_bytes() {
  _impl_.memory_used_bytes_ = uint64_t{0u};
}
inline uint64_t GPUInfo::_internal_memory_used_bytes() const {
  return _impl_.memory_used_bytes_;
}
inline uint64_t GPUInfo::memory_used_bytes() const {
  // @@protoc_insertion_point(field_get:SystemHealthy.GPUInfo.memory_used_bytes)
  return _internal_memory_used_bytes();
}
inline void GPUInfo::_internal_set_memory_used_bytes(uint64_t value) {
  
  _impl_.memory_used_bytes_ = value;
}
inline void GPUInfo::set_memory_used_bytes(uint64_t value) {
  _internal_set_memory_used_bytes(value);
  // @@protoc_insertion_point(field_set:SystemHealthy.GPUInfo.memory_used_bytes)
}

// repeated .SystemHealthy.GPUCoreInfo cores = 6;
inline int GPUInfo::_internal_cores_size() const {
  return _impl_.cores_.size();
}
inline int GPUInfo::cores_size() const {
  return _internal_cores_size();
}
inline void GPUInfo::clear_cores() {
  _impl_.cores_.Clear();
}
inline ::SystemHealthy::GPUCoreInfo* GPUInfo::mutable_cores(int index) {
  // @@protoc_insertion_point(field_mutable:SystemHealthy.GPUInfo.cores)
  return _impl_.cores_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SystemHealthy::GPUCoreInfo >*
GPUInfo::mutable_cores() {
  // @@protoc_insertion_point(field_mutable_list:SystemHealthy.GPUInfo.cores)
  return &_impl_.cores_;
}
inline const ::SystemHealthy::GPUCoreInfo& GPUInfo::_internal_cores(int index) const {
  return _impl_.cores_.Get(index);
}
inline const ::SystemHealthy::GPUCoreInfo& GPUInfo::cores(int index) const {
  // @@protoc_insertion_point(field_get:SystemHealthy.GPUInfo.cores)
  return _internal_cores(index);
}
inline ::SystemHealthy::GPUCoreInfo* GPUInfo::_internal_add_cores() {
  return _impl_.cores_.Add();
}
inline ::SystemHealthy::GPUCoreInfo* GPUInfo::add_cores() {
  ::SystemHealthy::GPUCoreInfo* _add = _internal_add_cores();
  // @@protoc_insertion_point(field_add:SystemHealthy.GPUInfo.cores)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SystemHealthy::GPUCoreInfo >&
GPUInfo::cores() const {
  // @@protoc_insertion_point(field_list:SystemHealthy.GPUInfo.cores)
  return _impl_.cores_;
}

// -------------------------------------------------------------------

// ProcessInfo

// int32 pid = 1;
inline void ProcessInfo::clear_pid() {
  _impl_.pid_ = 0;
}
inline int32_t ProcessInfo::_internal_pid() const {
  return _impl_.pid_;
}
inline int32_t ProcessInfo::pid() const {
  // @@protoc_insertion_point(field_get:SystemHealthy.ProcessInfo.pid)
  return _internal_pid();
}
inline void ProcessInfo::_internal_set_pid(int32_t value) {
  
  _impl_.pid_ = value;
}
inline void ProcessInfo::set_pid(int32_t value) {
  _internal_set_pid(value);
  // @@protoc_insertion_point(field_set:SystemHealthy.ProcessInfo.pid)
}

// string name = 2;
inline void ProcessInfo::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& ProcessInfo::name() const {
  // @@protoc_insertion_point(field_get:SystemHealthy.ProcessInfo.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcessInfo::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SystemHealthy.ProcessInfo.name)
}
inline std::string* ProcessInfo::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:SystemHealthy.ProcessInfo.name)
  return _s;
}
inline const std::string& ProcessInfo::_internal_name() const {
  return _impl_.name_.Get();
}
inline void ProcessInfo::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* ProcessInfo::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* ProcessInfo::release_name() {
  // @@protoc_insertion_point(field_release:SystemHealthy.ProcessInfo.name)
  return _impl_.name_.Release();
}
inline void ProcessInfo::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SystemHealthy.ProcessInfo.name)
}

// float cpu_percent = 3;
inline void ProcessInfo::clear_cpu_percent() {
  _impl_.cpu_percent_ = 0;
}
inline float ProcessInfo::_internal_cpu_percent() const {
  return _impl_.cpu_percent_;
}
inline float ProcessInfo::cpu_percent() const {
  // @@protoc_insertion_point(field_get:SystemHealthy.ProcessInfo.cpu_percent)
  return _internal_cpu_percent();
}
inline void ProcessInfo::_internal_set_cpu_percent(float value) {
  
  _impl_.cpu_percent_ = value;
}
inline void ProcessInfo::set_cpu_percent(float value) {
  _internal_set_cpu_percent(value);
  // @@protoc_insertion_point(field_set:SystemHealthy.ProcessInfo.cpu_percent)
}

// float mem_percent = 4;
inline void ProcessInfo::clear_mem_percent() {
  _impl_.mem_percent_ = 0;
}
inline float ProcessInfo::_internal_mem_percent() const {
  return _impl_.mem_percent_;
}
inline float ProcessInfo::mem_percent() const {
  // @@protoc_insertion_point(field_get:SystemHealthy.ProcessInfo.mem_percent)
  return _internal_mem_percent();
}
inline void ProcessInfo::_internal_set_mem_percent(float value) {
  
  _impl_.mem_percent_ = value;
}
inline void ProcessInfo::set_mem_percent(float value) {
  _internal_set_mem_percent(value);
  // @@protoc_insertion_point(field_set:SystemHealthy.ProcessInfo.mem_percent)
}

// -------------------------------------------------------------------

// SystemInfo

// string os_name = 1;
inline void SystemInfo::clear_os_name() {
  _impl_.os_name_.ClearToEmpty();
}
inline const std::string& SystemInfo::os_name() const {
  // @@protoc_insertion_point(field_get:SystemHealthy.SystemInfo.os_name)
  return _internal_os_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SystemInfo::set_os_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.os_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SystemHealthy.SystemInfo.os_name)
}
inline std::string* SystemInfo::mutable_os_name() {
  std::string* _s = _internal_mutable_os_name();
  // @@protoc_insertion_point(field_mutable:SystemHealthy.SystemInfo.os_name)
  return _s;
}
inline const std::string& SystemInfo::_internal_os_name() const {
  return _impl_.os_name_.Get();
}
inline void SystemInfo::_internal_set_os_name(const std::string& value) {
  
  _impl_.os_name_.Set(value, GetArenaForAllocation());
}
inline std::string* SystemInfo::_internal_mutable_os_name() {
  
  return _impl_.os_name_.Mutable(GetArenaForAllocation());
}
inline std::string* SystemInfo::release_os_name() {
  // @@protoc_insertion_point(field_release:SystemHealthy.SystemInfo.os_name)
  return _impl_.os_name_.Release();
}
inline void SystemInfo::set_allocated_os_name(std::string* os_name) {
  if (os_name != nullptr) {
    
  } else {
    
  }
  _impl_.os_name_.SetAllocated(os_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.os_name_.IsDefault()) {
    _impl_.os_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SystemHealthy.SystemInfo.os_name)
}

// string platform = 2;
inline void SystemInfo::clear_platform() {
  _impl_.platform_.ClearToEmpty();
}
inline const std::string& SystemInfo::platform() const {
  // @@protoc_insertion_point(field_get:SystemHealthy.SystemInfo.platform)
  return _internal_platform();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SystemInfo::set_platform(ArgT0&& arg0, ArgT... args) {
 
 _impl_.platform_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SystemHealthy.SystemInfo.platform)
}
inline std::string* SystemInfo::mutable_platform() {
  std::string* _s = _internal_mutable_platform();
  // @@protoc_insertion_point(field_mutable:SystemHealthy.SystemInfo.platform)
  return _s;
}
inline const std::string& SystemInfo::_internal_platform() const {
  return _impl_.platform_.Get();
}
inline void SystemInfo::_internal_set_platform(const std::string& value) {
  
  _impl_.platform_.Set(value, GetArenaForAllocation());
}
inline std::string* SystemInfo::_internal_mutable_platform() {
  
  return _impl_.platform_.Mutable(GetArenaForAllocation());
}
inline std::string* SystemInfo::release_platform() {
  // @@protoc_insertion_point(field_release:SystemHealthy.SystemInfo.platform)
  return _impl_.platform_.Release();
}
inline void SystemInfo::set_allocated_platform(std::string* platform) {
  if (platform != nullptr) {
    
  } else {
    
  }
  _impl_.platform_.SetAllocated(platform, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.platform_.IsDefault()) {
    _impl_.platform_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SystemHealthy.SystemInfo.platform)
}

// uint64 uptime_seconds = 3;
inline void SystemInfo::clear_uptime_seconds() {
  _impl_.uptime_seconds_ = uint64_t{0u};
}
inline uint64_t SystemInfo::_internal_uptime_seconds() const {
  return _impl_.uptime_seconds_;
}
inline uint64_t SystemInfo::uptime_seconds() const {
  // @@protoc_insertion_point(field_get:SystemHealthy.SystemInfo.uptime_seconds)
  return _internal_uptime_seconds();
}
inline void SystemInfo::_internal_set_uptime_seconds(uint64_t value) {
  
  _impl_.uptime_seconds_ = value;
}
inline void SystemInfo::set_uptime_seconds(uint64_t value) {
  _internal_set_uptime_seconds(value);
  // @@protoc_insertion_point(field_set:SystemHealthy.SystemInfo.uptime_seconds)
}

// .SystemHealthy.CPUInfo cpu_info = 4;
inline bool SystemInfo::_internal_has_cpu_info() const {
  return this != internal_default_instance() && _impl_.cpu_info_ != nullptr;
}
inline bool SystemInfo::has_cpu_info() const {
  return _internal_has_cpu_info();
}
inline void SystemInfo::clear_cpu_info() {
  if (GetArenaForAllocation() == nullptr && _impl_.cpu_info_ != nullptr) {
    delete _impl_.cpu_info_;
  }
  _impl_.cpu_info_ = nullptr;
}
inline const ::SystemHealthy::CPUInfo& SystemInfo::_internal_cpu_info() const {
  const ::SystemHealthy::CPUInfo* p = _impl_.cpu_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::SystemHealthy::CPUInfo&>(
      ::SystemHealthy::_CPUInfo_default_instance_);
}
inline const ::SystemHealthy::CPUInfo& SystemInfo::cpu_info() const {
  // @@protoc_insertion_point(field_get:SystemHealthy.SystemInfo.cpu_info)
  return _internal_cpu_info();
}
inline void SystemInfo::unsafe_arena_set_allocated_cpu_info(
    ::SystemHealthy::CPUInfo* cpu_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.cpu_info_);
  }
  _impl_.cpu_info_ = cpu_info;
  if (cpu_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SystemHealthy.SystemInfo.cpu_info)
}
inline ::SystemHealthy::CPUInfo* SystemInfo::release_cpu_info() {
  
  ::SystemHealthy::CPUInfo* temp = _impl_.cpu_info_;
  _impl_.cpu_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::SystemHealthy::CPUInfo* SystemInfo::unsafe_arena_release_cpu_info() {
  // @@protoc_insertion_point(field_release:SystemHealthy.SystemInfo.cpu_info)
  
  ::SystemHealthy::CPUInfo* temp = _impl_.cpu_info_;
  _impl_.cpu_info_ = nullptr;
  return temp;
}
inline ::SystemHealthy::CPUInfo* SystemInfo::_internal_mutable_cpu_info() {
  
  if (_impl_.cpu_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::SystemHealthy::CPUInfo>(GetArenaForAllocation());
    _impl_.cpu_info_ = p;
  }
  return _impl_.cpu_info_;
}
inline ::SystemHealthy::CPUInfo* SystemInfo::mutable_cpu_info() {
  ::SystemHealthy::CPUInfo* _msg = _internal_mutable_cpu_info();
  // @@protoc_insertion_point(field_mutable:SystemHealthy.SystemInfo.cpu_info)
  return _msg;
}
inline void SystemInfo::set_allocated_cpu_info(::SystemHealthy::CPUInfo* cpu_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.cpu_info_;
  }
  if (cpu_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(cpu_info);
    if (message_arena != submessage_arena) {
      cpu_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cpu_info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.cpu_info_ = cpu_info;
  // @@protoc_insertion_point(field_set_allocated:SystemHealthy.SystemInfo.cpu_info)
}

// .SystemHealthy.MemInfo mem_info = 5;
inline bool SystemInfo::_internal_has_mem_info() const {
  return this != internal_default_instance() && _impl_.mem_info_ != nullptr;
}
inline bool SystemInfo::has_mem_info() const {
  return _internal_has_mem_info();
}
inline void SystemInfo::clear_mem_info() {
  if (GetArenaForAllocation() == nullptr && _impl_.mem_info_ != nullptr) {
    delete _impl_.mem_info_;
  }
  _impl_.mem_info_ = nullptr;
}
inline const ::SystemHealthy::MemInfo& SystemInfo::_internal_mem_info() const {
  const ::SystemHealthy::MemInfo* p = _impl_.mem_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::SystemHealthy::MemInfo&>(
      ::SystemHealthy::_MemInfo_default_instance_);
}
inline const ::SystemHealthy::MemInfo& SystemInfo::mem_info() const {
  // @@protoc_insertion_point(field_get:SystemHealthy.SystemInfo.mem_info)
  return _internal_mem_info();
}
inline void SystemInfo::unsafe_arena_set_allocated_mem_info(
    ::SystemHealthy::MemInfo* mem_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.mem_info_);
  }
  _impl_.mem_info_ = mem_info;
  if (mem_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SystemHealthy.SystemInfo.mem_info)
}
inline ::SystemHealthy::MemInfo* SystemInfo::release_mem_info() {
  
  ::SystemHealthy::MemInfo* temp = _impl_.mem_info_;
  _impl_.mem_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::SystemHealthy::MemInfo* SystemInfo::unsafe_arena_release_mem_info() {
  // @@protoc_insertion_point(field_release:SystemHealthy.SystemInfo.mem_info)
  
  ::SystemHealthy::MemInfo* temp = _impl_.mem_info_;
  _impl_.mem_info_ = nullptr;
  return temp;
}
inline ::SystemHealthy::MemInfo* SystemInfo::_internal_mutable_mem_info() {
  
  if (_impl_.mem_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::SystemHealthy::MemInfo>(GetArenaForAllocation());
    _impl_.mem_info_ = p;
  }
  return _impl_.mem_info_;
}
inline ::SystemHealthy::MemInfo* SystemInfo::mutable_mem_info() {
  ::SystemHealthy::MemInfo* _msg = _internal_mutable_mem_info();
  // @@protoc_insertion_point(field_mutable:SystemHealthy.SystemInfo.mem_info)
  return _msg;
}
inline void SystemInfo::set_allocated_mem_info(::SystemHealthy::MemInfo* mem_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.mem_info_;
  }
  if (mem_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(mem_info);
    if (message_arena != submessage_arena) {
      mem_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, mem_info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.mem_info_ = mem_info;
  // @@protoc_insertion_point(field_set_allocated:SystemHealthy.SystemInfo.mem_info)
}

// .SystemHealthy.DiskInfo disk_info = 6;
inline bool SystemInfo::_internal_has_disk_info() const {
  return this != internal_default_instance() && _impl_.disk_info_ != nullptr;
}
inline bool SystemInfo::has_disk_info() const {
  return _internal_has_disk_info();
}
inline void SystemInfo::clear_disk_info() {
  if (GetArenaForAllocation() == nullptr && _impl_.disk_info_ != nullptr) {
    delete _impl_.disk_info_;
  }
  _impl_.disk_info_ = nullptr;
}
inline const ::SystemHealthy::DiskInfo& SystemInfo::_internal_disk_info() const {
  const ::SystemHealthy::DiskInfo* p = _impl_.disk_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::SystemHealthy::DiskInfo&>(
      ::SystemHealthy::_DiskInfo_default_instance_);
}
inline const ::SystemHealthy::DiskInfo& SystemInfo::disk_info() const {
  // @@protoc_insertion_point(field_get:SystemHealthy.SystemInfo.disk_info)
  return _internal_disk_info();
}
inline void SystemInfo::unsafe_arena_set_allocated_disk_info(
    ::SystemHealthy::DiskInfo* disk_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.disk_info_);
  }
  _impl_.disk_info_ = disk_info;
  if (disk_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SystemHealthy.SystemInfo.disk_info)
}
inline ::SystemHealthy::DiskInfo* SystemInfo::release_disk_info() {
  
  ::SystemHealthy::DiskInfo* temp = _impl_.disk_info_;
  _impl_.disk_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::SystemHealthy::DiskInfo* SystemInfo::unsafe_arena_release_disk_info() {
  // @@protoc_insertion_point(field_release:SystemHealthy.SystemInfo.disk_info)
  
  ::SystemHealthy::DiskInfo* temp = _impl_.disk_info_;
  _impl_.disk_info_ = nullptr;
  return temp;
}
inline ::SystemHealthy::DiskInfo* SystemInfo::_internal_mutable_disk_info() {
  
  if (_impl_.disk_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::SystemHealthy::DiskInfo>(GetArenaForAllocation());
    _impl_.disk_info_ = p;
  }
  return _impl_.disk_info_;
}
inline ::SystemHealthy::DiskInfo* SystemInfo::mutable_disk_info() {
  ::SystemHealthy::DiskInfo* _msg = _internal_mutable_disk_info();
  // @@protoc_insertion_point(field_mutable:SystemHealthy.SystemInfo.disk_info)
  return _msg;
}
inline void SystemInfo::set_allocated_disk_info(::SystemHealthy::DiskInfo* disk_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.disk_info_;
  }
  if (disk_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(disk_info);
    if (message_arena != submessage_arena) {
      disk_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, disk_info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.disk_info_ = disk_info;
  // @@protoc_insertion_point(field_set_allocated:SystemHealthy.SystemInfo.disk_info)
}

// .SystemHealthy.NetInfo net_info = 7;
inline bool SystemInfo::_internal_has_net_info() const {
  return this != internal_default_instance() && _impl_.net_info_ != nullptr;
}
inline bool SystemInfo::has_net_info() const {
  return _internal_has_net_info();
}
inline void SystemInfo::clear_net_info() {
  if (GetArenaForAllocation() == nullptr && _impl_.net_info_ != nullptr) {
    delete _impl_.net_info_;
  }
  _impl_.net_info_ = nullptr;
}
inline const ::SystemHealthy::NetInfo& SystemInfo::_internal_net_info() const {
  const ::SystemHealthy::NetInfo* p = _impl_.net_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::SystemHealthy::NetInfo&>(
      ::SystemHealthy::_NetInfo_default_instance_);
}
inline const ::SystemHealthy::NetInfo& SystemInfo::net_info() const {
  // @@protoc_insertion_point(field_get:SystemHealthy.SystemInfo.net_info)
  return _internal_net_info();
}
inline void SystemInfo::unsafe_arena_set_allocated_net_info(
    ::SystemHealthy::NetInfo* net_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.net_info_);
  }
  _impl_.net_info_ = net_info;
  if (net_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SystemHealthy.SystemInfo.net_info)
}
inline ::SystemHealthy::NetInfo* SystemInfo::release_net_info() {
  
  ::SystemHealthy::NetInfo* temp = _impl_.net_info_;
  _impl_.net_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::SystemHealthy::NetInfo* SystemInfo::unsafe_arena_release_net_info() {
  // @@protoc_insertion_point(field_release:SystemHealthy.SystemInfo.net_info)
  
  ::SystemHealthy::NetInfo* temp = _impl_.net_info_;
  _impl_.net_info_ = nullptr;
  return temp;
}
inline ::SystemHealthy::NetInfo* SystemInfo::_internal_mutable_net_info() {
  
  if (_impl_.net_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::SystemHealthy::NetInfo>(GetArenaForAllocation());
    _impl_.net_info_ = p;
  }
  return _impl_.net_info_;
}
inline ::SystemHealthy::NetInfo* SystemInfo::mutable_net_info() {
  ::SystemHealthy::NetInfo* _msg = _internal_mutable_net_info();
  // @@protoc_insertion_point(field_mutable:SystemHealthy.SystemInfo.net_info)
  return _msg;
}
inline void SystemInfo::set_allocated_net_info(::SystemHealthy::NetInfo* net_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.net_info_;
  }
  if (net_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(net_info);
    if (message_arena != submessage_arena) {
      net_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, net_info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.net_info_ = net_info;
  // @@protoc_insertion_point(field_set_allocated:SystemHealthy.SystemInfo.net_info)
}

// repeated .SystemHealthy.GPUInfo gpu_infos = 8;
inline int SystemInfo::_internal_gpu_infos_size() const {
  return _impl_.gpu_infos_.size();
}
inline int SystemInfo::gpu_infos_size() const {
  return _internal_gpu_infos_size();
}
inline void SystemInfo::clear_gpu_infos() {
  _impl_.gpu_infos_.Clear();
}
inline ::SystemHealthy::GPUInfo* SystemInfo::mutable_gpu_infos(int index) {
  // @@protoc_insertion_point(field_mutable:SystemHealthy.SystemInfo.gpu_infos)
  return _impl_.gpu_infos_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SystemHealthy::GPUInfo >*
SystemInfo::mutable_gpu_infos() {
  // @@protoc_insertion_point(field_mutable_list:SystemHealthy.SystemInfo.gpu_infos)
  return &_impl_.gpu_infos_;
}
inline const ::SystemHealthy::GPUInfo& SystemInfo::_internal_gpu_infos(int index) const {
  return _impl_.gpu_infos_.Get(index);
}
inline const ::SystemHealthy::GPUInfo& SystemInfo::gpu_infos(int index) const {
  // @@protoc_insertion_point(field_get:SystemHealthy.SystemInfo.gpu_infos)
  return _internal_gpu_infos(index);
}
inline ::SystemHealthy::GPUInfo* SystemInfo::_internal_add_gpu_infos() {
  return _impl_.gpu_infos_.Add();
}
inline ::SystemHealthy::GPUInfo* SystemInfo::add_gpu_infos() {
  ::SystemHealthy::GPUInfo* _add = _internal_add_gpu_infos();
  // @@protoc_insertion_point(field_add:SystemHealthy.SystemInfo.gpu_infos)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SystemHealthy::GPUInfo >&
SystemInfo::gpu_infos() const {
  // @@protoc_insertion_point(field_list:SystemHealthy.SystemInfo.gpu_infos)
  return _impl_.gpu_infos_;
}

// repeated .SystemHealthy.ProcessInfo processes = 9;
inline int SystemInfo::_internal_processes_size() const {
  return _impl_.processes_.size();
}
inline int SystemInfo::processes_size() const {
  return _internal_processes_size();
}
inline void SystemInfo::clear_processes() {
  _impl_.processes_.Clear();
}
inline ::SystemHealthy::ProcessInfo* SystemInfo::mutable_processes(int index) {
  // @@protoc_insertion_point(field_mutable:SystemHealthy.SystemInfo.processes)
  return _impl_.processes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SystemHealthy::ProcessInfo >*
SystemInfo::mutable_processes() {
  // @@protoc_insertion_point(field_mutable_list:SystemHealthy.SystemInfo.processes)
  return &_impl_.processes_;
}
inline const ::SystemHealthy::ProcessInfo& SystemInfo::_internal_processes(int index) const {
  return _impl_.processes_.Get(index);
}
inline const ::SystemHealthy::ProcessInfo& SystemInfo::processes(int index) const {
  // @@protoc_insertion_point(field_get:SystemHealthy.SystemInfo.processes)
  return _internal_processes(index);
}
inline ::SystemHealthy::ProcessInfo* SystemInfo::_internal_add_processes() {
  return _impl_.processes_.Add();
}
inline ::SystemHealthy::ProcessInfo* SystemInfo::add_processes() {
  ::SystemHealthy::ProcessInfo* _add = _internal_add_processes();
  // @@protoc_insertion_point(field_add:SystemHealthy.SystemInfo.processes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SystemHealthy::ProcessInfo >&
SystemInfo::processes() const {
  // @@protoc_insertion_point(field_list:SystemHealthy.SystemInfo.processes)
  return _impl_.processes_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace SystemHealthy

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_SystemHealthy_2eproto
